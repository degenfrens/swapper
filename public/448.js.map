{"version":3,"file":"448.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AADA;AAAA;;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;;;AAGA;;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AAnBA;;;AAuBA;AAzCA;AA2CA;AACA;;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;;;AAGA;;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAPA;AASA;AACA;AAjCA;;;AAqCA;;;AA1GA;AAAA;AAAA;AAAA;;;AA8GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAFA;AAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjIA;AAAA;AAAA;;AAIA;AACA;AACA;AAEA;;;AACA;;AAEA;AACA;AACA;AACA;;;AAIA;;AACA;AACA;AATA;;;;;;AAgBA;AACA;;AACA;AACA;;AAEA;AAKA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AAFA;AAKA;AACA;AAFA;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAaA;AACA;AACA;AAGA;AAIA;AACA;AACA;;AA1BA;AAAA;;AA2BA;;AA3BA;AA2BA;;AA3BA;AAAA;AAAA;;;AAAA;AA6BA;AAAA;;AA7BA;AAAA;AAAA;AAAA;;;AAAA;AA8BA;AAAA;;AA9BA;AAAA;AAgCA;AAAA;;AAhCA;AAAA;AAAA;AAAA;;AAAA;;;;;AAmCA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAFA;AAAA;AAAA;;;AAAA;;AAAA;AAoBA;AApBA;AAuBA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAdA;;AAtBA;AAAA;AAAA;AAAA;;AAAA","sources":["webpack://@degenfrens/swapper/../src/hooks/routing/transformSwapRouteToGetQuoteResult.ts","webpack://@degenfrens/swapper/../src/hooks/routing/clientSideSmartOrderRouter.ts"],"sourcesContent":["import { Protocol } from '@uniswap/router-sdk'\nimport type { SwapRoute } from '@uniswap/smart-order-router'\nimport { QuoteResult, QuoteState, V2PoolInRoute, V3PoolInRoute } from 'state/routing/types'\nimport { isExactInput } from 'utils/tradeType'\n\n// from routing-api (https://github.com/Uniswap/routing-api/blob/main/lib/handlers/quote/quote.ts#L243-L311)\nexport function transformSwapRouteToGetQuoteResult({\n  quote,\n  quoteGasAdjusted,\n  route,\n  routeString,\n  estimatedGasUsed,\n  estimatedGasUsedQuoteToken,\n  estimatedGasUsedUSD,\n  gasPriceWei,\n  methodParameters,\n  blockNumber,\n  trade: { tradeType, inputAmount, outputAmount },\n}: SwapRoute & { routeString: string }): QuoteResult {\n  const routeResponse: Array<V3PoolInRoute[] | V2PoolInRoute[]> = []\n\n  for (const subRoute of route) {\n    const { amount, quote, tokenPath } = subRoute\n\n    if (subRoute.protocol === Protocol.V3) {\n      const pools = subRoute.route.pools\n      const curRoute: V3PoolInRoute[] = []\n      for (let i = 0; i < pools.length; i++) {\n        const nextPool = pools[i]\n        const tokenIn = tokenPath[i]\n        const tokenOut = tokenPath[i + 1]\n\n        let edgeAmountIn = undefined\n        if (i === 0) {\n          edgeAmountIn = isExactInput(tradeType) ? amount.quotient.toString() : quote.quotient.toString()\n        }\n\n        let edgeAmountOut = undefined\n        if (i === pools.length - 1) {\n          edgeAmountOut = isExactInput(tradeType) ? quote.quotient.toString() : amount.quotient.toString()\n        }\n\n        curRoute.push({\n          type: 'v3-pool',\n          tokenIn: {\n            chainId: tokenIn.chainId,\n            decimals: tokenIn.decimals,\n            address: tokenIn.address,\n            symbol: tokenIn.symbol,\n          },\n          tokenOut: {\n            chainId: tokenOut.chainId,\n            decimals: tokenOut.decimals,\n            address: tokenOut.address,\n            symbol: tokenOut.symbol,\n          },\n          fee: nextPool.fee.toString(),\n          liquidity: nextPool.liquidity.toString(),\n          sqrtRatioX96: nextPool.sqrtRatioX96.toString(),\n          tickCurrent: nextPool.tickCurrent.toString(),\n          amountIn: edgeAmountIn,\n          amountOut: edgeAmountOut,\n        })\n      }\n\n      routeResponse.push(curRoute)\n    } else if (subRoute.protocol === Protocol.V2) {\n      const pools = subRoute.route.pairs\n      const curRoute: V2PoolInRoute[] = []\n      for (let i = 0; i < pools.length; i++) {\n        const nextPool = pools[i]\n        const tokenIn = tokenPath[i]\n        const tokenOut = tokenPath[i + 1]\n\n        let edgeAmountIn = undefined\n        if (i === 0) {\n          edgeAmountIn = isExactInput(tradeType) ? amount.quotient.toString() : quote.quotient.toString()\n        }\n\n        let edgeAmountOut = undefined\n        if (i === pools.length - 1) {\n          edgeAmountOut = isExactInput(tradeType) ? quote.quotient.toString() : amount.quotient.toString()\n        }\n\n        const reserve0 = nextPool.reserve0\n        const reserve1 = nextPool.reserve1\n\n        curRoute.push({\n          type: 'v2-pool',\n          tokenIn: {\n            chainId: tokenIn.chainId,\n            decimals: tokenIn.decimals,\n            address: tokenIn.address,\n            symbol: tokenIn.symbol,\n          },\n          tokenOut: {\n            chainId: tokenOut.chainId,\n            decimals: tokenOut.decimals,\n            address: tokenOut.address,\n            symbol: tokenOut.symbol,\n          },\n          reserve0: {\n            token: {\n              chainId: reserve0.currency.wrapped.chainId,\n              decimals: reserve0.currency.wrapped.decimals,\n              address: reserve0.currency.wrapped.address,\n              symbol: reserve0.currency.wrapped.symbol,\n            },\n            quotient: reserve0.quotient.toString(),\n          },\n          reserve1: {\n            token: {\n              chainId: reserve1.currency.wrapped.chainId,\n              decimals: reserve1.currency.wrapped.decimals,\n              address: reserve1.currency.wrapped.address,\n              symbol: reserve1.currency.wrapped.symbol,\n            },\n            quotient: reserve1.quotient.toString(),\n          },\n          amountIn: edgeAmountIn,\n          amountOut: edgeAmountOut,\n        })\n      }\n\n      routeResponse.push(curRoute)\n    }\n  }\n\n  const amount = isExactInput(tradeType) ? inputAmount : outputAmount\n  return {\n    state: QuoteState.SUCCESS,\n    data: {\n      methodParameters,\n      blockNumber: blockNumber.toString(),\n      amount: amount.quotient.toString(),\n      amountDecimals: amount.toExact(),\n      quote: quote.quotient.toString(),\n      quoteDecimals: quote.toExact(),\n      quoteGasAdjusted: quoteGasAdjusted.quotient.toString(),\n      quoteGasAdjustedDecimals: quoteGasAdjusted.toExact(),\n      gasUseEstimateQuote: estimatedGasUsedQuoteToken.quotient.toString(),\n      gasUseEstimateQuoteDecimals: estimatedGasUsedQuoteToken.toExact(),\n      gasUseEstimate: estimatedGasUsed.toString(),\n      gasUseEstimateUSD: estimatedGasUsedUSD.toExact(),\n      gasPriceWei: gasPriceWei.toString(),\n      route: routeResponse,\n      routeString,\n    },\n  }\n}\n","import { BaseProvider } from '@ethersproject/providers'\nimport { BigintIsh, ChainId, CurrencyAmount, Token, TradeType } from '@uniswap/sdk-core'\nimport type { AlphaRouterConfig } from '@uniswap/smart-order-router'\n// This file is lazy-loaded, so the import of smart-order-router is intentional.\n// eslint-disable-next-line @typescript-eslint/no-restricted-imports\nimport {\n  AlphaRouter,\n  OnChainQuoteProvider,\n  routeAmountsToString,\n  StaticV2SubgraphProvider,\n  UniswapMulticallProvider,\n} from '@uniswap/smart-order-router'\nimport { nativeOnChain } from 'constants/tokens'\nimport JSBI from 'jsbi'\nimport { GetQuoteArgs, QuoteResult, QuoteState } from 'state/routing/types'\nimport { isExactInput } from 'utils/tradeType'\n\nimport { transformSwapRouteToGetQuoteResult } from './transformSwapRouteToGetQuoteResult'\nimport { SwapRouterNativeAssets } from './types'\n\nconst AUTO_ROUTER_SUPPORTED_CHAINS: ChainId[] = Object.values(ChainId).filter((chainId): chainId is ChainId =>\n  Number.isInteger(chainId)\n)\n\nfunction isAutoRouterSupportedChain(chainId: ChainId | undefined): boolean {\n  return Boolean(chainId && AUTO_ROUTER_SUPPORTED_CHAINS.includes(chainId))\n}\n\n/** A cache of AlphaRouters, which must be initialized to a specific chain/provider. */\nconst routersCache = new WeakMap<BaseProvider, { [chainId: number]: AlphaRouter }>()\n\nfunction getRouter(chainId: ChainId, provider: BaseProvider): AlphaRouter {\n  const routers = routersCache.get(provider) || {}\n  const cached = routers[chainId]\n  if (cached) return cached\n\n  // V2 is unsupported for chains other than mainnet.\n  // TODO(zzmp): Upstream to @uniswap/smart-order-router, exporting an enum of supported v2 chains for clarity.\n  let v2SubgraphProvider\n  if (chainId !== ChainId.MAINNET) {\n    v2SubgraphProvider = new StaticV2SubgraphProvider(chainId)\n  }\n\n  // V3 computes on-chain, so the quoter must have gas limits appropriate to the provider.\n  // Most defaults are fine, but polygon needs a lower gas limit.\n  // TODO(zzmp): Upstream to @uniswap/smart-order-router, possibly making this easier to modify\n  // (eg allowing configuration without an instance to avoid duplicating multicall2Provider).\n  let onChainQuoteProvider\n  let multicall2Provider\n  if ([ChainId.POLYGON, ChainId.POLYGON_MUMBAI].includes(chainId)) {\n    multicall2Provider = new UniswapMulticallProvider(chainId, provider, 375_000)\n    // See https://github.com/Uniswap/smart-order-router/blob/98c58bdee9981fd9ffac9e7d7a97b18302d5f77a/src/routers/alpha-router/alpha-router.ts#L464-L487\n    onChainQuoteProvider = new OnChainQuoteProvider(\n      chainId,\n      provider,\n      multicall2Provider,\n      {\n        retries: 2,\n        minTimeout: 100,\n        maxTimeout: 1000,\n      },\n      {\n        multicallChunk: 10,\n        gasLimitPerCall: 5_000_000,\n        quoteMinSuccessRate: 0.1,\n      },\n      {\n        gasLimitOverride: 5_000_000,\n        multicallChunk: 5,\n      },\n      {\n        gasLimitOverride: 6_250_000,\n        multicallChunk: 4,\n      }\n    )\n  }\n\n  const router = new AlphaRouter({ chainId, provider, v2SubgraphProvider, multicall2Provider, onChainQuoteProvider })\n  routers[chainId] = router\n  routersCache.set(provider, routers)\n  return router\n}\n\nasync function getQuoteResult(\n  {\n    tradeType,\n    tokenIn,\n    tokenOut,\n    amount: amountRaw,\n  }: {\n    tradeType: TradeType\n    tokenIn: { address: string; chainId: number; decimals: number; symbol?: string }\n    tokenOut: { address: string; chainId: number; decimals: number; symbol?: string }\n    amount: BigintIsh | null\n  },\n  router: AlphaRouter,\n  routerConfig: Partial<AlphaRouterConfig>\n): Promise<QuoteResult> {\n  const tokenInIsNative = Object.values(SwapRouterNativeAssets).includes(tokenIn.address as SwapRouterNativeAssets)\n  const tokenOutIsNative = Object.values(SwapRouterNativeAssets).includes(tokenOut.address as SwapRouterNativeAssets)\n  const currencyIn = tokenInIsNative\n    ? nativeOnChain(tokenIn.chainId)\n    : new Token(tokenIn.chainId, tokenIn.address, tokenIn.decimals, tokenIn.symbol)\n  const currencyOut = tokenOutIsNative\n    ? nativeOnChain(tokenOut.chainId)\n    : new Token(tokenOut.chainId, tokenOut.address, tokenOut.decimals, tokenOut.symbol)\n\n  const baseCurrency = isExactInput(tradeType) ? currencyIn : currencyOut\n  const quoteCurrency = isExactInput(tradeType) ? currencyOut : currencyIn\n  const amount = CurrencyAmount.fromRawAmount(baseCurrency, JSBI.BigInt(amountRaw ?? '1')) // a null amountRaw should initialize the route\n  const route = await router.route(amount, quoteCurrency, tradeType, /*swapConfig=*/ undefined, routerConfig)\n\n  if (!amountRaw) return { state: QuoteState.INITIALIZED }\n  if (!route) return { state: QuoteState.NOT_FOUND }\n\n  return transformSwapRouteToGetQuoteResult({ ...route, routeString: routeAmountsToString(route.route) })\n}\n\nexport async function getClientSideQuoteResult(\n  {\n    tokenInAddress,\n    tokenInChainId,\n    tokenInDecimals,\n    tokenInSymbol,\n    tokenOutAddress,\n    tokenOutChainId,\n    tokenOutDecimals,\n    tokenOutSymbol,\n    amount,\n    tradeType,\n    provider,\n  }: GetQuoteArgs,\n  routerConfig: Partial<AlphaRouterConfig>\n) {\n  if (!isAutoRouterSupportedChain(tokenInChainId)) {\n    throw new Error(`Router does not support this token's chain (chainId: ${tokenInChainId}).`)\n  }\n\n  const router = getRouter(tokenInChainId, provider)\n  return getQuoteResult(\n    {\n      tradeType,\n      tokenIn: {\n        address: tokenInAddress,\n        chainId: tokenInChainId,\n        decimals: tokenInDecimals,\n        symbol: tokenInSymbol,\n      },\n      tokenOut: {\n        address: tokenOutAddress,\n        chainId: tokenOutChainId,\n        decimals: tokenOutDecimals,\n        symbol: tokenOutSymbol,\n      },\n      amount,\n    },\n    router,\n    routerConfig\n  )\n}\n"],"names":[],"sourceRoot":""}